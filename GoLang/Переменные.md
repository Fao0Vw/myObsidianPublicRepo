Если имя начинается с прописной буквы, оно *экспорти­руемое* -  это означает, что оно видимо и доступно за пределами собственного пакета и
к нему могут обращаться другие части программы, как в случае функции Printf из
пакета fmt.

**Способы инициализация:**
- Используя ключевое слово var (*var name type = expression*)
- Краткая инициализация (name := expression)


Один тонкий, но важный момент: краткое объявление переменной не обязательно
объявляет все переменные в своей левой части. Если некоторые из них уже были объ­явлены в том же лексическом блоке (раздел 2.7), то для этих переменных краткие
объявления действуют как присваивания.
В приведенном ниже коде первая инструкция объявляет как in, так и err. Вторая
объявляет только out, а уже существующей переменной err она присваивает значение.
`in, err := os.Open(infile)`
`/ / . . .`
`out, err := os.Create(outfile)`
Однако краткое объявление переменной должно объявлять по крайней мере одну
новую переменную, так что приведенный ниже код не компилируется:
`f, err := os.Open(infile)`
`I / . ..`
`f, err := os.Create(outfile) // Ошибка: нет новой переменной`
Чтобы исправить ошибку, во второй инструкции следует использовать обычное
присваивание.
Краткое объявление переменной действует как присваивание только для перемен­ных, которые уже были объявлены в том же лексическом блоке; объявления во внеш­нем блоке игнорируются. 



`func createPointer() *int {`
    `x := 42          // локальная переменная x объявлена в стеке`
    `return &x        // возвращаем указатель на переменную x`
`}`

`func main() {`
    `p := createPointer()  // p получает указатель на x`
    `fmt.Println(*p)       // выводим значение по указателю`
`}`




